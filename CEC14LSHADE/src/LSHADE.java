import java.util.ArrayList;
import java.util.List;

/**
 * Created by framg on 23/04/2016.
 */
public class LSHADE {
    private double [][] pop;
    private double [] fitness;
    private double [][] children;
    private double [] children_fitness;

    public int arc_size;
    public double arc_rate;
    public double p_best_rate;
    public int memory_size;
    public int reduction_ind_num;


    int pop_size;
    double optimum;
    double epsilon;
    int problem_size;
    int max_num_evaluations;


    public LSHADE(){
        pop_size = Configuration.pop_size;
        optimum = bias.getBias(Configuration.F);
        epsilon = Configuration.epsilon;
        problem_size = Configuration.N;
        max_num_evaluations = Configuration.MAX_FES;



        pop = new double[Configuration.pop_size][Configuration.N];
        fitness = new double[Configuration.pop_size];
        children = new double[Configuration.pop_size][Configuration.N];
        children_fitness = new double[Configuration.pop_size];


    }


    public double execute()
    {
        //initializeParameters();
        setSHADEParameters();

        //initialize population
        for (int i = 0; i < pop_size; i++)
        {
            pop[i] = Util.copyArray(makeNewIndividual());
        }

        // evaluate the initial population's fitness values
        fitness = evaluatePopulation(pop);

        double[] bsf_solution = new double[problem_size];
        double bsf_fitness;
        int nfes = 0;

        if ((fitness[0] - optimum) < epsilon)
        {
            fitness[0] =  optimum;
        }
        bsf_fitness = fitness[0];
        for (int j = 0; j < problem_size; j++)
        {
            bsf_solution[j] = pop[0][j];
        }
        /////////////////////////////////////////////////////////////////////////
        for (int i = 0; i < pop_size; i++)
        {
            nfes++;

            if ((fitness[i] - optimum) < epsilon)
            {
                fitness[i] =  optimum;
            }

            if (fitness[i] < bsf_fitness)
            {
                bsf_fitness = fitness[i];
                for (int j = 0; j < problem_size; j++)
                {
                    bsf_solution[j] = pop[i][j];
                }
            }

            // if (nfes % 1000 == 0) {
            //   //      cout << nfes << " " << bsf_fitness - optimum << endl;
            //   cout << bsf_fitness - optimum << endl;
            // }

            if (nfes >= max_num_evaluations)
                break;
        }
        ////////////////////////////////////////////////////////////////////////////

        //for external archive
        int arc_ind_count = 0;
        int random_selected_arc_ind;
        double [][] archive = new double[arc_size][problem_size];

        int num_success_params;
        List<Double> success_sf= new ArrayList<>();
        List<Double> success_cr= new ArrayList<>();
        List<Double> dif_fitness = new ArrayList<>();

        // the contents of M_f and M_cr are all initialiezed 0.5
        double [] memory_sf = new double[memory_size];
        double []  memory_cr = new double[memory_size];

        Util.assignArray(memory_cr, 0.5);
        Util.assignArray(memory_sf, 0.5);

        double temp_sum_sf;
        double temp_sum_cr;
        double sum;
        double weight;

        //memory index counter
        int memory_pos = 0;

        //for new parameters sampling
        double mu_sf;
        double mu_cr;
        int random_selected_period;
        double[] pop_sf = new double[pop_size];
        double[] pop_cr = new double[pop_size];

        //for current-to-pbest/1
        int p_best_ind;
        int p_num = (int)Math.round(pop_size * p_best_rate);
        int[] sorted_array = new int[pop_size];
        double[] temp_fit = new double[pop_size];

        // for linear population size reduction
        int max_pop_size = pop_size;
        int min_pop_size = 4;
        int plan_pop_size;

        //main loop
        while (nfes < max_num_evaluations && bsf_fitness - optimum > Configuration.epsilon)
        {
            for (int i = 0; i < pop_size; i++)
            {
                sorted_array[i] = i;
            }
            for (int i = 0; i < pop_size; i++)
            {
                temp_fit[i] = fitness[i];
            }
            sorted_array = Util.sort(temp_fit);
            //sortIndexWithQuickSort(temp_fit[0], 0, pop_size - 1, sorted_array);

            for (int target = 0; target < pop_size; target++)
            {
                //In each generation, CR_i and F_i used by each individual x_i are generated by first selecting an index r_i randomly from [1, H]
                random_selected_period =  Configuration.rand.getInt(0, memory_size-1); //(int)(Configuration.rand.getFloat() % memory_size);
                mu_sf = memory_sf[random_selected_period];
                mu_cr = memory_cr[random_selected_period];

                //generate CR_i and repair its value
                if (mu_cr == -1)
                {
                    pop_cr[target] = 0;
                }
                else
                {
                    pop_cr[target] = Configuration.rand.gaussian(mu_cr, 0.1);
                    if (pop_cr[target] > 1)
                    {
                        pop_cr[target] = 1;
                    }
                    else if (pop_cr[target] < 0)
                    {
                        pop_cr[target] = 0;
                    }
                }

                //generate F_i and repair its value
                do
                {
                    pop_sf[target] = Configuration.rand.cauchyrnd(mu_sf, 0.1);
                } while (pop_sf[target] <= 0);

                if (pop_sf[target] > 1)
                {
                    pop_sf[target] = 1;
                }

                //p-best individual is randomly selected from the top pop_size *  p_i members
                //p_best_ind = sorted_array[(int)(Configuration.rand.getFloat() % p_num)];
                p_best_ind = sorted_array[Configuration.rand.getInt(0, p_num-1)];
                /**
                 *void LSHADE::operateCurrentToPBest1BinWithArchive(const vector<Individual> &pop, Individual child, int &target, int &p_best_individual, variable &scaling_factor, variable &cross_rate, const vector<Individual> &archive, int &arc_ind_count)
                 *
                 */
                //operateCurrentToPBest1BinWithArchive(pop, children[target][0], target, p_best_ind, pop_sf[target], pop_cr[target], archive, arc_ind_count);
                int r1, r2;
                double cross_rate =  pop_cr[target];
                double scaling_factor = pop_sf[target];
                do {
                    r1 = Configuration.rand.getInt(0, pop_size-1);  //Math.round(Configuration.rand.getFloat() % pop_size);
                } while (r1 == target);
                do {
                    r2 = Configuration.rand.getInt(0, pop_size + arc_ind_count -1);   //Math.round(Configuration.rand.getFloat() % (pop_size + arc_ind_count));
                } while ((r2 == target) || (r2 == r1));

                int random_variable =  Configuration.rand.getInt(0, problem_size-1);  //Math.round(Configuration.rand.getFloat() % problem_size);

                if (r2 >= pop_size) {
                    r2 -= pop_size;
                    for (int i = 0; i < problem_size; i++) {
                        if ((Configuration.rand.getFloat() < cross_rate) || (i == random_variable)) {
                            children[target][i] = pop[target][i] + scaling_factor * (pop[p_best_ind][i] - pop[target][i]) + scaling_factor * (pop[r1][i] - archive[r2][i]);
                        }
                        else {
                            children[target][i] = pop[target][i];
                        }
                    }
                }
                else {
                    for (int i = 0; i < problem_size; i++) {
                        if ((Configuration.rand.getFloat() < cross_rate) || (i == random_variable)) {
                            children[target][i] = pop[target][i] + scaling_factor * (pop[p_best_ind][i] - pop[target][i]) + scaling_factor * (pop[r1][i] - pop[r2][i]);
                        }
                        else {
                            children[target][i] = pop[target][i];
                        }
                    }
                }

                //If the mutant vector violates bounds, the bound handling method is applied
                modifySolutionWithParentMedium(children[target],  pop[target]);

                /**************************************************************************************/



            }

            // evaluate the children's fitness values
            children_fitness = evaluatePopulation(children);

            /////////////////////////////////////////////////////////////////////////
            //update the bsf-solution and check the current number of fitness evaluations
            // if the current number of fitness evaluations over the max number of fitness evaluations, the search is terminated
            // So, this program is unconcerned about L-SHADE algorithm directly
            for (int i = 0; i < pop_size; i++)
            {
                nfes++;

                //following the rules of CEC 2014 real parameter competition,
                //if the gap between the error values of the best solution found and the optimal solution was 10^{âˆ’8} or smaller,
                //the error was treated as 0
                if ((children_fitness[i] - optimum) < epsilon)
                {
                    children_fitness[i] = optimum;
                }

                if (children_fitness[i] < bsf_fitness)
                {
                    bsf_fitness = children_fitness[i];
                    for (int j = 0; j < problem_size; j++)
                    {
                        bsf_solution[j] = children[i][j];
                    }
                }
                System.out.println("Value: " + bsf_fitness + " at: " + nfes);

                // if (nfes % 1000 == 0) {
                // //      cout << nfes << " " << bsf_fitness - optimum << endl;
                // 	cout << bsf_fitness - optimum << endl;
                // }
                if (nfes >= max_num_evaluations)
                    break;
            }
            ////////////////////////////////////////////////////////////////////////////

            //generation alternation
            for (int i = 0; i < pop_size; i++)
            {
                if (children_fitness[i] == fitness[i])
                {
                    fitness[i] = children_fitness[i];
                    for (int j = 0; j < problem_size; j++)
                    {
                        pop[i][j] = children[i][j];
                    }
                }
                else if (children_fitness[i] < fitness[i])
                {
                    dif_fitness.add(Math.abs(fitness[i] - children_fitness[i]));
                    fitness[i] = children_fitness[i];
                    for (int j = 0; j < problem_size; j++)
                    {
                        pop[i][j] = children[i][j];
                    }

                    //successful parameters are preserved in S_F and S_CR
                    success_sf.add(pop_sf[i]);
                    success_cr.add(pop_cr[i]);

                    //parent vectors x_i which were worse than the trial vectors u_i are preserved
                    if (arc_size > 1)
                    {
                        if (arc_ind_count < arc_size)
                        {
                            for (int j = 0; j < problem_size; j++)
                            {
                                archive[arc_ind_count][j] = pop[i][j];
                            }
                            arc_ind_count++;
                        }
                        //Whenever the size of the archive exceeds, randomly selected elements are deleted to make space for the newly inserted elements
                        else
                        {
                            random_selected_arc_ind = Configuration.rand.getInt(0, arc_size-1);  //(int)(Configuration.rand.getFloat() % arc_size);
                            for (int j = 0; j < problem_size; j++)
                            {
                                archive[random_selected_arc_ind][j] = pop[i][j];
                            }
                        }
                    }
                }
            }

            num_success_params = success_sf.size();



            // if numeber of successful parameters > 0, historical memories are updated
            if (num_success_params > 0)
            {
                memory_sf[memory_pos] = 0;
                memory_cr[memory_pos] = 0;
                temp_sum_sf = 0;
                temp_sum_cr = 0;
                sum = 0;

                for (int i = 0; i < num_success_params; i++)
                {
                    sum += dif_fitness.get(i);
                }

                //weighted lehmer mean
                for (int i = 0; i < num_success_params; i++)
                {
                    weight = dif_fitness.get(i) / sum;

                    memory_sf[memory_pos] = memory_sf[memory_pos] + weight * success_sf.get(i) * success_sf.get(i);
                    temp_sum_sf += weight * success_sf.get(i);

                    memory_cr[memory_pos] =  memory_cr[memory_pos] + weight * success_cr.get(i) * success_cr.get(i);
                    temp_sum_cr += weight * success_cr.get(i);
                }

                memory_sf[memory_pos] = memory_sf[memory_pos] / temp_sum_sf;

                if (temp_sum_cr == 0 || memory_cr[memory_pos] == -1)
                {
                    memory_cr[memory_pos] = -1;
                }
                else
                {
                    memory_cr[memory_pos] = memory_cr[memory_pos] / temp_sum_cr;
                }

                //increment the counter
                memory_pos++;
                if (memory_pos >= memory_size)
                {
                    memory_pos = 0;
                }

                //clear out the S_F, S_CR and delta fitness
                success_sf.clear();
                success_cr.clear();
                dif_fitness.clear();
            }

            // calculate the population size in the next generation
            plan_pop_size = (int) Math.round((((min_pop_size - max_pop_size) / (double)max_num_evaluations) * nfes) + max_pop_size);

            if (pop_size > plan_pop_size)
            {
                reduction_ind_num = pop_size - plan_pop_size;
                if (pop_size - reduction_ind_num < min_pop_size)
                {
                    reduction_ind_num = pop_size - min_pop_size;
                }

                reducePopulationWithSort(pop, fitness);

                // resize the archive size
                arc_size = (int)(pop_size * Configuration.g_arc_rate);
                if (arc_ind_count > arc_size)
                {
                    arc_ind_count = arc_size;
                }

                // resize the number of p-best individuals
                p_num = (int)Math.round(pop_size * p_best_rate);
                if (p_num <= 1)
                {
                    p_num = 2;
                }
            }
        }

        return bsf_fitness - optimum;
    }




    public void setSHADEParameters()
    {
        arc_rate = Configuration.g_arc_rate;
        arc_size = (int)Math.round(pop_size * arc_rate);
        p_best_rate = Configuration.g_p_best_rate;
        memory_size = Configuration.g_memory_size;
    }




    public void reducePopulationWithSort(double [][] pop, double [] fitness)
    {
        int worst_ind;

        for (int i = 0; i < reduction_ind_num; i++)
        {
            worst_ind = 0;
            for (int j = 1; j < pop_size; j++)
            {
                if (fitness[j] > fitness[worst_ind])
                {
                    worst_ind = j;
                }
            }
            pop = Util.eraseMember(pop, worst_ind);
            fitness = Util.eraseMember(fitness, worst_ind);
            pop_size--;
        }
    }



    private double [] makeNewIndividual(){
        double [] individual = new double[problem_size];
        for(int j=0; j<problem_size; j++){
            individual[j] = Bounds.getLowerBound(Configuration.F) + Configuration.rand.getFloat()* (Bounds.getUpperBound(Configuration.F) - Bounds.getLowerBound(Configuration.F));
        }

        return individual;
    }

    private double [] evaluatePopulation(double [][] pop){
        double [] new_fitness = new double[pop_size];

        for(int i=0; i<pop_size; i++){
            new_fitness[i] = Configuration.benchmark.f(pop[i]);
        }
        return new_fitness;
    }


    void modifySolutionWithParentMedium(double [] child, double [] parent) {
        int l_problem_size = problem_size;
        double l_min_region = Bounds.getLowerBound(Configuration.F);
        double l_max_region = Bounds.getUpperBound(Configuration.F);

        for (int j = 0; j < l_problem_size; j++) {
            if (child[j] < l_min_region) {
                child[j]= (l_min_region + parent[j]) / 2.0;
            }
            else if (child[j] > l_max_region) {
                child[j]= (l_max_region + parent[j]) / 2.0;
            }
        }
    }

}
